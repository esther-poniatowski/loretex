"""
ARCHIVED: No longer maintained, replaced by dynamic Jiinja templates in the `meta.yaml` file.
====================================================================================================
Generate structured Conda requirements from `pyproject.toml`.

Steps:

1. Extract dependencies from `pyproject.toml` and export them to `requirements.txt`,
   using the `pyproject2conda` tool.
2. Parse `requirements.txt` to extract core and optional dependencies.
3. Format these dependencies into a structured YAML fragment suitable for Conda's `meta.yaml`
   Jinja-templating.
4. Write the structured requirements to `conda.recipe.dev/fragments/requirements.yaml`.

It includes both core and optional dependencies, and formats them according to Conda's expected
structure for the 'host' and 'run' sections.

Input file: `pyproject.toml`.
Internal file: `requirements.txt` (generated by `pyproject2conda`).
Output file: `conda.recipe.dev/fragments/requirements.yaml`.

Dependencies
------------
- pyproject2conda
- pyyaml

Notes
-----
- The `pyproject.toml` must follow PEP 621 specification.
- Optional dependencies are included based on predefined extras.
- This script does not modify `meta.yaml` itself, but only the dependency fragment.

Usage
-----
To generate the fragment:

>>> python scripts/generate_meta_fragments.py

"""

from pathlib import Path
from typing import Optional

import yaml

from pyproject2conda.requirements import ParseDepends


def extract_dependencies(
    path_toml: Path = Path("pyproject.toml"),
    path_yaml: Path = Path("tmp.yaml"),
    extras: Optional[list[str]] = None,
    python_include: str = "infer",
    save: bool = False
) -> str:
    """
    Extract dependency requirements from `pyproject.toml` using `pyproject2conda`.

    The result contains the declared Python version, mandatory dependencies, and a predefined set
    of optional dependencies.

    It can optionally be saved as a temporary YAML file for debugging or transparency.

    Example output:

    ```yaml
    channels:
        - conda-forge
        - defaults
    dependencies:
      - python>=3.12
      - numpy
      - pandas
      - pip

    Arguments
    ---------
    path_toml : Path, default=Path("pyproject.toml")
        Path to the input `pyproject.toml` file.
    path_yaml : Path, default=Path("tmp.yaml")
        File to write the requirements fragment in YAML format, if `save` is True.
    extras : list of str, optional
        Optional dependency groups to include. Example: ["dev", "docs"].
    python_include : str, default="infer"
        Option to specify how to include Python version. Defaults to "infer" which determines the
        python version from the `requires-python` field in `pyproject.toml`.
    save : bool, default=False
        If True, writes the raw output to a YAML file for transparency or debugging.

    Returns
    -------
    yaml_output : str
        Raw YAML output string containing the dependencies formatted for Conda.

    See Also
    --------
    pyproject2conda.requirements.ParseDepends:
        Class to parse dependencies from `pyproject.toml`.

        Relevant attributes include (for future usage if needed):

        - `dependencies`: List of core dependencies.
        - `optional_dependencies`: Dictionary of optional dependencies keyed by their group names.
        - `package_name`: Name of the package as defined in `pyproject.toml`.
        - `build_system_requires`: List of build system requirements.
        - `channels`: List of Conda channels specified in `pyproject.toml` under the
          `tool.pyproject2conda.channels` key.
        - `extras`: Available extras.

    pyproject2conda.requirements.ParseDepends.to_conda_yaml:
        Method to convert parsed dependencies to Conda YAML format.
    """
    if not extras:
        extras = []
    p = ParseDepends.from_path(path_toml)
    yaml_str = p.to_conda_yaml(python_include=python_include, extras=extras).strip()
    if save:
        path_yaml.parent.mkdir(parents=True, exist_ok=True)
        with path_yaml.open("w") as file:
            yaml.dump(yaml_str, file, sort_keys=False)
    return yaml_str


def wrap_into_meta_fragment(
        yaml_str: Optional[str] = None,
        path_yaml: Path = Path("tmp.yaml"),
        path_req: Path = Path("requirements.yaml"),
        save: bool = True
    ) -> str:
    """
    Wraps the raw YAML output into a structured YAML fragment suitable for Conda's `meta.yaml`
    Jinja-templating.

    The result is formatted into a `requirements` dictionary with two sections:

    - 'host': Includes the Python version and `pip` as a build dependency.
    - 'run' sections: Includes the `dependencies` from the raw YAML output.

    Example output:

    ```yaml
    requirements:
      host:
        - python >=3.12
        - pip
      run:
        - <dependencies from yaml_str>
    ```

    Arguments
    ---------
    yaml_str : str, optional
        Raw YAML string containing the dependencies formatted for Conda.
        If not provided, it will read from `path_yaml`.
    path_yaml : Path, default=Path("tmp.yaml")
        Path to the input YAML file containing the raw dependencies, if `yaml_str` is not provided.
    path_req : Path, default=Path("requirements.yaml")
        Path to the final YAML fragment output.
    save : bool, default=True
        If True, writes the structured requirements to `path_req`.
    """

    requirements_yaml = {
        "requirements": {
            "host": [
                "python >=3.12",
                "pip"
            ],
            "run": deps
        }
    }
    if save:
        path_yaml.parent.mkdir(parents=True, exist_ok=True)
        with path_yaml.open("w") as f:
            yaml.dump(requirements_yaml, f, sort_keys=False)


def main():
    """
    Main function to generate the Conda requirements fragment.
    """
    base = Path("conda.recipe.dev/fragments")
    generate_conda_fragment(
        raw_txt_path=base / "requirements.txt",
        yaml_output_path=base / "requirements.yaml",
        extras=["dev"]
    )

if __name__ == "__main__":
    main()
